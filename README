Notes:

Instructor:  brian d foy
Version:     3.1
Date:        10/14/2013

perldoc perlvar

perldoc -f eval

perldoc -q comma

perldoc perlop

http:://perldoc.perl.com


-------------------------------------------
Review of grep:
-------------------------------------------

my @numbers = 1..1000;
my @odd_numbers;
foreach (@numbers) {
	push @odd_numbers, $_ if $_ % 2;
}

or

my @odd_numbers = grep $_ % 2, 1..1000;

my @result = grep expression, list;

As in foreach $_ is aliased to the elements of the original list, careful, don't change $_ unless you intend to change the original list.

also:

my @matching = grep /\bMinow\b/, <FILE>;  # gets the matching lines


Perl Power Tools - adds perl implemenations of grep and other linux stuff to Windows. COOL ***

-------------------------------------------
Review of map:
-------------------------------------------

my @foods = qw/ COCONUTS Rice mangoes Wild_boar /;
my @good_case;
foreach (@foods) {
	push @good_case, "\u\L$_";
}

or

my @good_case = map "\u\L$_", @foods;

Can be used inline.

print "The foods are:\n", map " $_\n", @good_case;

Its all list processing. Just like the linux pipeline.
Called the UNIX toolbox.
LISP - also very good at this...

Higher Order Perl - Mark Jas
Perl has 6 of the 7 things that define LISP.

Case Shifters in string interpretation.

Call a subroutine:

my @files &funct($_), glob "*";
my @strings = map &funct($_), <FILE>;

-------------------------------------------
Annomyous subroutine:
-------------------------------------------
my @strings = map {
	my $copy = $_;
	$copy =~ s/^\s+//;

	$copy; # return
} <FILE>


($new = $orig) =~ s///;

$new = $orig =~ s///r;  # 5.14 /r returns results instead of count.

@out = map { s/// } @in; # array of counts substitute
@out = map { s///r } @in; # array of strings with substitutes.

-------------------------------------------
Mapping one to many:
-------------------------------------------
my @file_names = glob "*";
my @names_and_sizes = map { $_, -s } @file_names;
my %size_of = @names_and_sizes;

# Shorter version
my %size_of = map { $_, -s } glob "*";

my @words = map split, <FILE>; # splits the whole file into words.

my @comments = map /#\s*(.*)/, <INPUT>;  # a list of # comments

-------------------------------------------
Review of eval:
-------------------------------------------
String form - bad one, genearally execute string as perl code.

Block form -

eval {
	open FH, $file or die "This is caught in $@";
	some_sub_that_dies(); #This is caught too
}
if ($@) {
	...
}

Does not trap normal execution, such as exit or warnings.
The code in the eval block must compile.
It doesn't catch syntax errors.

die "xxx"; # xxx file# line#
die "xxx/n" # xxx

-------------------------------------------
Introduction to References
-------------------------------------------
my @last_three = pop_n(3, @foos);

passed a n+1 item list 3, ?, ?, ?, ?, ...

my @last_three = pop_n(3, \@foos);

passes a 2 item list.  3, ref @foos

PeGS...

Write a Perl module to generate PeGS.

$ref = \@count

| ref >
					| count >
					===========
|  * | ------------>     5
                         4
                         3
                         2
                         1

A reference is just a scalar.

sub pop_n {
	my ($n, $array_ref) = @_;
	...
}

$array_ref is just a "pointer" to the array.

Daily WTF.

printf "%${width}s\n";  # ahha here is the fix to $abc_abb where ${abc}_abb.

@array = @{$array_ref};

Its just about naming...

sub pop_n {
	my ($n, $array_ref) = @_;
	my @items;

	for (1..$n) {
		my $item = pop @{ $array_ref };
		unshift @items, $item;
	}

	@items; #return value.
}

# Test it now...
my @foods = qw/ clam coconut fish /;
my @last_3 = pop_n(3 \@foods);
print "@foods\n";

If you pass in 0 for $n?  1..0 => undef, returns @items -> undef.

Additional ways to access an array:

my $count = @{$array_ref};
my $last = $#{$array_ref};
my @two = @{$array_ref} [1, 2];

Hash references:

my $ref = \%file_size;

${$ref}{item} = ???
@{$ref}[0]

Scalar references:

How to make perl release memory?

sub strip_span {
	my $string_ref = shift;
	$$string_ref =~ s/<\?span.*?>//s;
}

Passing a scalar by value creates a copy. Pass by reference is better for big data, think strings.

You can compare references to see if they point to the same data.

Modifying the array:

my @gilligan = qw(red_shirt hat lucky_socks water_bottle);

check_required_items("gilligan", \@gilligan);

sub check_required_items {
	my $who = shift;
	my $items = shift;

	my %items = map { $_, 1} @$items;
	state @required = qw(preserver sunscreen water_botle jacket); # state requires 5.10. (similar to static, initialized the first time only.)

	my @missing = ();

	foreach my $item (@requried) {
		unless (exists $items{$item}) {
			print
			push @missing, $item;
		}
	}

	if (@missing) {
		print "Adding @missing to @$items for $who.\n";
		push @$items, @missing;
	}
}

Defereferenceing with deeply nested structures gets very complicated.

Prefer to use the -> to do the dereference.

$all[2]->[1]->[0] = ${ ${ $all[2] } [1] }[0];

also you can use:

$all[2][1][0]