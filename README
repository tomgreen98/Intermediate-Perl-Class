Notes:

Instructor:  brian d foy
Version:     3.1
Date:        10/14/2013

perldoc perlvar

perldoc -f eval

perldoc -q comma

perldoc perlop

http:://perldoc.perl.com


-------------------------------------------
Review of grep:
-------------------------------------------

my @numbers = 1..1000;
my @odd_numbers;
foreach (@numbers) {
	push @odd_numbers, $_ if $_ % 2;
}

or

my @odd_numbers = grep $_ % 2, 1..1000;

my @result = grep expression, list;

As in foreach $_ is aliased to the elements of the original list, careful, don't change $_ unless you intend to change the original list.

also:

my @matching = grep /\bMinow\b/, <FILE>;  # gets the matching lines


Perl Power Tools - adds perl implemenations of grep and other linux stuff to Windows. COOL ***

-------------------------------------------
Review of map:
-------------------------------------------

my @foods = qw/ COCONUTS Rice mangoes Wild_boar /;
my @good_case;
foreach (@foods) {
	push @good_case, "\u\L$_";
}

or

my @good_case = map "\u\L$_", @foods;

Can be used inline.

print "The foods are:\n", map " $_\n", @good_case;

Its all list processing. Just like the linux pipeline.
Called the UNIX toolbox.
LISP - also very good at this...

Higher Order Perl - Mark Jas
Perl has 6 of the 7 things that define LISP.

Case Shifters in string interpretation.

Call a subroutine:

my @files &funct($_), glob "*";
my @strings = map &funct($_), <FILE>;

-------------------------------------------
Annomyous subroutine:
-------------------------------------------
my @strings = map {
	my $copy = $_;
	$copy =~ s/^\s+//;

	$copy; # return
} <FILE>


($new = $orig) =~ s///;

$new = $orig =~ s///r;  # 5.14 /r returns results instead of count.

@out = map { s/// } @in; # array of counts substitute
@out = map { s///r } @in; # array of strings with substitutes.

-------------------------------------------
Mapping one to many:
-------------------------------------------
my @file_names = glob "*";
my @names_and_sizes = map { $_, -s } @file_names;
my %size_of = @names_and_sizes;

# Shorter version
my %size_of = map { $_, -s } glob "*";

my @words = map split, <FILE>; # splits the whole file into words.

my @comments = map /#\s*(.*)/, <INPUT>;  # a list of # comments

-------------------------------------------
Review of eval:
-------------------------------------------
String form - bad one, genearally execute string as perl code.

Block form -

eval {
	open FH, $file or die "This is caught in $@";
	some_sub_that_dies(); #This is caught too
}
if ($@) {
	...
}

Does not trap normal execution, such as exit or warnings.
The code in the eval block must compile.
It doesn't catch syntax errors.

die "xxx"; # xxx file# line#
die "xxx/n" # xxx

-------------------------------------------
Introduction to References
-------------------------------------------
my @last_three = pop_n(3, @foos);

passed a n+1 item list 3, ?, ?, ?, ?, ...

my @last_three = pop_n(3, \@foos);

passes a 2 item list.  3, ref @foos

PeGS...

Write a Perl module to generate PeGS.

$ref = \@count

| ref >
					| count >
					===========
|  * | ------------>     5
                         4
                         3
                         2
                         1

A reference is just a scalar.

sub pop_n {
	my ($n, $array_ref) = @_;
	...
}

$array_ref is just a "pointer" to the array.

Daily WTF.

printf "%${width}s\n";  # ahha here is the fix to $abc_abb where ${abc}_abb.

@array = @{$array_ref};

Its just about naming...

sub pop_n {
	my ($n, $array_ref) = @_;
	my @items;

	for (1..$n) {
		my $item = pop @{ $array_ref };
		unshift @items, $item;
	}

	@items; #return value.
}

# Test it now...
my @foods = qw/ clam coconut fish /;
my @last_3 = pop_n(3 \@foods);
print "@foods\n";

If you pass in 0 for $n?  1..0 => undef, returns @items -> undef.

Additional ways to access an array:

my $count = @{$array_ref};
my $last = $#{$array_ref};
my @two = @{$array_ref} [1, 2];

Hash references:

my $ref = \%file_size;

${$ref}{item} = ???
@{$ref}[0]

Scalar references:

How to make perl release memory?

sub strip_span {
	my $string_ref = shift;
	$$string_ref =~ s/<\?span.*?>//s;
}

Passing a scalar by value creates a copy. Pass by reference is better for big data, think strings.

You can compare references to see if they point to the same data.

Modifying the array:

my @gilligan = qw(red_shirt hat lucky_socks water_bottle);

check_required_items("gilligan", \@gilligan);

sub check_required_items {
	my $who = shift;
	my $items = shift;

	my %items = map { $_, 1} @$items;
	state @required = qw(preserver sunscreen water_botle jacket); # state requires 5.10. (similar to static, initialized the first time only.)

	my @missing = ();

	foreach my $item (@requried) {
		unless (exists $items{$item}) {
			print
			push @missing, $item;
		}
	}

	if (@missing) {
		print "Adding @missing to @$items for $who.\n";
		push @$items, @missing;
	}
}

Defereferenceing with deeply nested structures gets very complicated.

Prefer to use the -> to do the dereference.

$all[2]->[1]->[0] = ${ ${ $all[2] } [1] }[0];

also you can use:

$all[2][1][0]


another way to build the hash:

@names = qw(skipper, gilligan, professor);

%all = map {
	$_, \@{"$_"}
} @names;

#doesn't work in strict, there is another way too coming up.
#don't do that...

%main::  -> stash  - tracks all the stuff.

foreach (keys %main::) {
	next unless defined @{"$_"};
	print "$_\n";
}

masteringperl.org -> new book by brian d foy.
intermediateperl.com -> this book.

How to use state actually?

state $required = [preserver sunscreen water_bottle life_jacket];  # should work.

--------------------------
References and Scoping:
--------------------------

my $ref = \@count;

my $ref2 = $ref;
or
my $ref2 = \@count;

Just a new name for the same reference.

When things go out of scope, the name dissapears, the data sticks around until all the references are released.

sub get_personal_info {
	local $_;
	my $who = shift;

	open (FILE, "clothing-size") or die "Can't open clithing-size file: $!";

	chomp($_ = <FILE>);
	my @headings = split /\t/;

	while(<FILE>) {
		chomp;
		my @data = split /\t/;
		next unless $data[0] eq $who;

		my %hash;
		@hash{@headings} = @data; # Hash slice assigns each data to each key

		close FILE;

		return \%hash;
	}

	close FILE;
	();
}

HoA -> Hash of Arrays
HoH -> Hash of Hashes

>> perldsc

----------------------
Auto-vivification:
----------------------

my %total_bytes;
while(<>) {
	my ($source, $dest, $bytes) = split;
	$total_bytes{$source}{$destination} += $bytes;
}

How to disable auto-vivication?

use autovivification;
 calls import();

use x; =>  BEGIN {require x; x->import;}


no autovivificaiton;

no x; => BEGIN {require x; x->unimport;}

---------------
Destruction
---------------
Add a ref ++ refcount
Remove a ref -- refcount
Once the refcount is 0, perl may release the memory, may not be right a way....

Can cause problems where structures cross reference each other.

Stephen (Linked list in perl)

-----------------------
Prototypical Checking
-----------------------
if (ref $some eq ref [] ) { ... } # array ref
if (ref $some eq ref {} ) { ... } # hash ref
if (ref $some eq ref qr() ) { ... } # regex ref

-----------------------
Section 5: Manipulating Complex Data Structures
-----------------------

What is a good perl visual debugger?

log for perl

Debuggers:

Devel::REPL
Devel::hdb

-------------------------------------------
Printing a structured value for debugging
-------------------------------------------
Data::Dumper;

------------------
Add column names:
------------------

print Data::Dumper->Dump(
	[ \%people, [ qw(a b c) ],
	[ qw(*people *array)],
)

* means add the correct type.

Data::Dump::Streamer - has fancier features.

Data::Printer -

p %hash;

------------------
YAML:
------------------

use YAML;
print Dump( \%people, [qw(a b c)]);

Now it outputs YAML...

To get it back:

use YAML;
my ($people, $array) = Load( $string );

YAML never evals so its safer...
Its available in other languages
There are other implementations:
 * YAML::Tiny
 * YAML::Syck

Security issues:

CGI::SpecFile

	DESTROY {
		unlink $$_[0];
	}

And Storable can be passed a string that can be iterpreted as this CGI::SpecFile class. Opps, you can unlink any file. YUCK.

----------------------------
Persistence with Storable
----------------------------

Sereal - Fixes all the known problems with Storable.

----------------------------
Subroutine References
----------------------------
Reduce repetition.

my $func_ref = \&func;

&func_ref();
&{$func_ref}();
&$func_ref();
$func_ref->(); # Added just before 5.04 released.

All these call the same function the same way...

Using multipe coderefs:

foreach my $greet_ref (\&a_greet, \&b_greet, \&c_greet) {
	$greet_ref->();
}

----------------------------
Anonymous Subroutine:
----------------------------
my $func_ref = sub {
	...
}

ASSIDE: (Cool use for state to get the loop counter.)
@output_list = map {
	state $n = 0;
	say "on element", $n++;
} @in;

----------------------------
Callbacks:
----------------------------
use File::Find;
sub what_to_do {
	print "$File::Find::name found.\n";
}

my @starting_points = qw{ . };

find(\&what_to_do, @starting_points);

There are several more variables:


ASSIDE: find2perl -> creates a perl subroutine that works like the find linux call, but all native perl and often more efficent since doesn't pipe to output processing...

----------------------------
Lexical variables in a surrounding scope
----------------------------

use File::Find;

my ($total_files, $total_bytes) = (0,0);

find(
	sub {
		return if -l or not -f _; # Not a link or not a file
		$total_files++;
		$total_bytes += -s _;
	},
	"."
);

print "Total: $total_bytes bytes in $total_files files.\n";


----------------------------
Closures
----------------------------

my $callback;

{
	# In the private scope
	my $count = 0;
	$callback = sub {
		# Creates a closure
		print ++$count, ": $File::Find::name\n";
		#$count has a refcount of 2
	}
}

#$count has a refcount of 1, so its still around

find ($callback, ".");

The above can be implemented with state in modern 5.010+ without the extra scope block.

---------------------------
Return a closure
---------------------------

use File::Find;
sub create_find_counter {
	my $count = 0;
	return sub {
		print ++$count, ": $File::Find::name\n";
	}
}

my $callback1 = create_find_counter();
my $callback2 = create_find_counter();

each have an independent count.


--------------------------------
Shared variables among closures
--------------------------------

use File::Find;

sub find_callback_and_report() {

	my ($total_files, $total_bytes) = (0,0);

	my $calc = sub {
		return if -l or not -f _; # Not a link or not a file
		$total_files++;
		$total_bytes += -s _;
	};

	my $report = sub {
		print "Total: $total_bytes bytes in $total_files files.\n";
	}
);

my ($calc, $report) = find_callback_and_report();

find($calc, ".");
find($calc, "./ab");
find($calc, "./ac");
$report->();

-----------------------------
File::Find::Closures
-----------------------------

-----------------------------
state variables
-----------------------------

use 5.010; or use v5.10;

-----------------------------
END blocks
-----------------------------
BEGIN blocks execute top to  bottom
END blocks execute bottom to top

only run if running is normal, not for crashes.



